
# 6. Grafos (Graph)

## Introducción a los Grafos

Un **grafo (graph)** es una estructura de datos compuesta por **nodos** (también llamados **vértices**) y **aristas** (o **enlaces**). Los grafos se utilizan para modelar relaciones entre diferentes entidades. Se utilizan ampliamente en problemas como el análisis de redes, la búsqueda en mapas, y la representación de sistemas interconectados.

![Grafo Visual](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/1920px-6n-graf.svg.png)

*(Visualización de un grafo: los círculos representan nodos y las líneas representan aristas)*

### Componentes de un Grafo

1. **Nodos (Vértices)**: Los elementos individuales del grafo.
2. **Aristas (Enlaces)**: Las conexiones entre los nodos. Pueden ser **dirigidas** (con un sentido) o **no dirigidas** (sin sentido específico).
3. **Peso (opcional)**: Algunas aristas pueden tener un peso o costo asociado.
4. **Grafo Dirigido**: Un grafo donde las aristas tienen una dirección, es decir, van de un nodo a otro en un solo sentido.
5. **Grafo No Dirigido**: Un grafo donde las aristas no tienen una dirección, es decir, la conexión entre dos nodos es bidireccional.

### Tipos de Grafos

1. **Grafo Dirigido**: Las aristas tienen una dirección, lo que significa que un nodo puede estar conectado a otro en una sola dirección.
2. **Grafo No Dirigido**: Las aristas no tienen dirección, por lo que la conexión entre dos nodos es bidireccional.
3. **Grafo Ponderado**: Un grafo donde cada arista tiene un valor o peso asociado, lo que puede representar distancia, tiempo o cualquier otra medida.
4. **Grafo Completo**: Un grafo donde cada nodo está conectado a todos los demás nodos.

### Representación de un Grafo

Existen varias formas de representar un grafo en un programa:

- **Lista de Adyacencia**: Cada nodo tiene una lista de nodos a los que está conectado.
- **Matriz de Adyacencia**: Una matriz que muestra si hay o no una conexión entre cada par de nodos.

#### Ejemplo de Representación de Lista de Adyacencia

```javascript
class Grafo {
    constructor() {
        this.adyacencia = new Map();
    }

    // Añadir un nodo al grafo
    añadirNodo(v) {
        this.adyacencia.set(v, []);
    }

    // Añadir una arista entre dos nodos
    añadirArista(v, w) {
        this.adyacencia.get(v).push(w);
        this.adyacencia.get(w).push(v);  // Si es un grafo no dirigido
    }

    // Mostrar el grafo
    mostrarGrafo() {
        for (let [nodo, lista] of this.adyacencia) {
            console.log(`${nodo} -> ${lista.join(', ')}`);
        }
    }
}

let grafo = new Grafo();
grafo.añadirNodo('A');
grafo.añadirNodo('B');
grafo.añadirNodo('C');
grafo.añadirArista('A', 'B');
grafo.añadirArista('A', 'C');
grafo.mostrarGrafo();
// A -> B, C
// B -> A
// C -> A
```

#### Ejemplo de Representación de Matriz de Adyacencia

```javascript
class GrafoMatriz {
    constructor(tamaño) {
        this.matriz = Array.from({ length: tamaño }, () => Array(tamaño).fill(0));
    }

    añadirArista(v1, v2) {
        this.matriz[v1][v2] = 1;
        this.matriz[v2][v1] = 1;  // Si es un grafo no dirigido
    }

    mostrarMatriz() {
        console.log(this.matriz);
    }
}

let grafoMatriz = new GrafoMatriz(3);
grafoMatriz.añadirArista(0, 1);
grafoMatriz.añadirArista(0, 2);
grafoMatriz.mostrarMatriz();
// Imprime una matriz de adyacencia 3x3
```

### Recorridos en un Grafo

Existen dos algoritmos populares para recorrer un grafo:

1. **Recorrido en Profundidad (DFS - Depth First Search)**: Se comienza desde un nodo y se explora cada rama completamente antes de retroceder.

2. **Recorrido en Anchura (BFS - Breadth First Search)**: Se comienza desde un nodo y se exploran todos los nodos vecinos antes de pasar a los siguientes niveles.

#### Ejemplo de DFS

```javascript
class GrafoDFS {
    constructor() {
        this.adyacencia = new Map();
    }

    añadirNodo(v) {
        this.adyacencia.set(v, []);
    }

    añadirArista(v, w) {
        this.adyacencia.get(v).push(w);
    }

    DFS(inicio, visitados = new Set()) {
        console.log(inicio);
        visitados.add(inicio);

        let vecinos = this.adyacencia.get(inicio);
        for (let vecino of vecinos) {
            if (!visitados.has(vecino)) {
                this.DFS(vecino, visitados);
            }
        }
    }
}

let grafoDFS = new GrafoDFS();
grafoDFS.añadirNodo('A');
grafoDFS.añadirNodo('B');
grafoDFS.añadirNodo('C');
grafoDFS.añadirArista('A', 'B');
grafoDFS.añadirArista('A', 'C');
grafoDFS.añadirArista('B', 'C');
grafoDFS.DFS('A');
// Imprime: A, B, C
```

### Aplicaciones Comunes de los Grafos

- **Redes Sociales**: Los usuarios son los nodos, y las conexiones entre ellos son las aristas.
- **Mapas**: Los puntos de interés son los nodos, y las carreteras son las aristas, a menudo ponderadas por la distancia.
- **Optimización de Rutas**: Los algoritmos de grafos se utilizan para encontrar rutas más cortas en sistemas de transporte.
- **Sistemas de Recomendación**: Los grafos se usan para modelar relaciones entre productos, usuarios y preferencias.

### Comparación con Otras Estructuras de Datos

- **Grafo vs Árbol**: Un árbol es un caso especial de grafo donde no hay ciclos y tiene una estructura jerárquica. Los grafos pueden tener ciclos y conexiones más complejas.
- **Grafo vs Lista Enlazada**: Las listas enlazadas son unidireccionales o bidireccionales, mientras que los grafos pueden tener conexiones más complejas entre múltiples nodos.

### Complejidad de las Operaciones

- **Añadir Nodo**: `O(1)`
- **Añadir Arista**: `O(1)` para lista de adyacencia, `O(n)` para matriz de adyacencia.
- **Recorridos DFS/BFS**: `O(V + E)`, donde `V` es el número de nodos y `E` es el número de aristas.

---

**[↩️ Regresar al índice](../README.md)**
